<?php
namespace Wise\Dispatcher;

/**
 * Class \Wise\Dispatcher\Dispatcher
 * 
 * This class execute, the plugins and the action of the route
 *
 * @author gdievart <dievartg@gmail.com>
 */
class Dispatcher extends \Wise\Component\Component
{
    /**
     * The methods name of precall
     * 
     * @staticvar string 
     */
    const PLUGIN_PRECALL = 'precall';
    
    /**
     * The methods name of postcall
     * 
     * @staticvar string 
     */
    const PLUGIN_POSTCALL = 'postcall';

    /**
     * Unique id generated by the route informations
     * 
     * @var string 
     */
    protected static $routeInfos;

    /**
     * Ref to the plugins already loaded
     * 
     * @var array 
     */
    protected $pluginsLoaded = array();

    /**
     * Flag to interrupt the request
     * 
     * @var boolean 
     */
    protected static $interruptRequest = false;
    
    /**
     * The action to execute
     *
     * @var callable
     */
    protected $action;

    /**
     * Response of the action
     * 
     * @var string 
     */
    protected static $response;
    
    /**
     * {@inherit}
     * @throws \Wise\Exception\Exception
     */
    protected function init($router)
    {
        if (!$router instanceof \Wise\Router\Router) {
            throw new \Wise\Exception\Exception();
        }
        $this->router = $router;
    }

    /**
     * Execute a route
     * 
     * @param string $route
     */
    public function run($route = null)
    {
        self::$routeInfos = $this->router->getRoute($route);
        $this->setRouteInfos();
        $this->executeRoute();
    }

    /**
     * Set informations from routeInfos
     */
    protected function setRouteInfos()
    {
        self::$routeInfos['route_id'] = md5(json_encode(self::$routeInfos));

        if (!empty(self::$routeInfos['action'])) {
            if (is_callable(self::$routeInfos['action'])) {
                $this->action = self::$routeInfos['action'];
            } elseif (strpos(self::$routeInfos['action'], '->') !== false) {
                $this->action = explode('->', self::$routeInfos['action']);
            }
        }
        
        $this->plugins[self::PLUGIN_PRECALL] = !empty(self::$routeInfos[self::PLUGIN_PRECALL]) ? self::$routeInfos[self::PLUGIN_PRECALL] : array();
        $this->plugins[self::PLUGIN_POSTCALL] = !empty(self::$routeInfos[self::PLUGIN_POSTCALL]) ? self::$routeInfos[self::PLUGIN_POSTCALL] : array();
    }

    /**
     * Execute the route
     */
    protected function executeRoute()
    {
        $this->executePlugins(self::PLUGIN_PRECALL);
        $this->executeAction();
        $this->executePlugins(self::PLUGIN_POSTCALL);
    }

    /**
     * Execute the plugins of the route
     *
     * @param string $method Precall or Postcall
     */
    protected function executePlugins($method)
    {
        foreach ($this->plugins[$method] as $plugin) {
            if(self::$interruptRequest) {
                break;
            }

            if (!isset($this->pluginsLoaded[$plugin])) {
                $this->pluginsLoaded[$plugin] = new $plugin();
            }

            $this->pluginsLoaded[$plugin]->$method();
        }
    }

    /**
     * Execute the action
     */
    protected function executeAction()
    {   
        self::$response = array();
        
        if (!self::$interruptRequest && $this->action !== null) {
            if (count($this->action) === 2) {
                $controller = new $this->action[0];
                $this->action = array($controller, $this->action[1]);
            }
            self::$response = call_user_func_array($this->action, self::$routeInfos['argv']);
        }
    }

    /**
     * Interrupt request and return response
     */
    public static function interruptRequest()
    {
        self::$interruptRequest = true;
    }

    /**
     * Retrieve route id
     *
     * @return string
     */
    public static function getRouteInfos()
    {
        return self::$routeId;
    }

    /**
     * Retrieve the response
     *
     * @return mixed
     */
    public static function getResponse()
    {
        return self::$response;
    }

    /**
     * Set the response
     *
     * @param mixed $response
     */
    public static function setResponse($response)
    {
        self::$response = $response;
    }
}
